# React의 State

## State란?

State는 **컴포넌트 내부에서 동적으로 변하는 데이터를 저장하는 JavaScript 객체**입니다.  
React에서 State는 컴포넌트 내부에서 변화하는 데이터를 관리하는 **핵심 개념**입니다.

## 주요 특징

- **State는 컴포넌트의 상태를 나타내며**, 이 상태가 변경되면 컴포넌트가 다시 렌더링됩니다.
- **컴포넌트의 UI를 동적으로 변경**할 때 사용됩니다.
- State는 React 컴포넌트 내부에서 관리하는 **변경 가능한 데이터**입니다.
- 컴포넌트가 렌더링될 때 `state`의 값이 사용되며, state 값이 변경되면 컴포넌트가 **자동으로 다시 렌더링**되어 화면이 업데이트됩니다.
- 이를 통해 사용자 인터페이스(UI)가 사용자와의 상호작용에 따라 **동적으로 변화**할 수 있습니다.
- State를 이해하고 효과적으로 사용하는 것은 **React 개발 능력을 향상시키는 데 필수적**입니다.

## 요약

- ✅ State는 **동적으로 변하는 데이터**를 저장합니다.  
- ✅ State 변경 시, **자동으로 UI가 업데이트**됩니다.  
- ✅ React의 **재렌더링을 트리거**하는 핵심 메커니즘입니다.  
- ✅ 효과적인 상태 관리가 곧 **성능과 사용자 경험의 향상**으로 이어집니다.

---
# State와 Props

## Props

- `props`는 **properties**의 줄임말로, **부모 컴포넌트에서 자식 컴포넌트로 데이터나 함수 등을 전달**할 때 사용됩니다.
- 부모 컴포넌트는 자식 컴포넌트에 props를 **주입(inject)**함으로써, 데이터를 전달하고 자식 컴포넌트의 동작을 **제어**할 수 있습니다.
- props는 **읽기 전용(read-only)**이며, 자식 컴포넌트는 이를 **수정할 수 없습니다**.

---



# React Hook 정리

## 🔹 Hook 등장 배경

- React 컴포넌트는 **함수형 컴포넌트(Functional Component)** 와 **클래스형 컴포넌트(Class Component)** 로 나뉩니다.
- 초기에는 함수형 컴포넌트를 사용했지만, **상태(state)** 관리나 **생명 주기(Lifecycle Methods)** 가 필요할 경우 클래스형 컴포넌트를 사용해야 했습니다.
- 클래스형 컴포넌트의 대표적인 단점:
  - 코드의 구성이 복잡하고 재사용성이 떨어짐
  - 컴파일 단계에서 코드 최적화가 어려움
  - 최신 기술의 적용이 효과적이지 않음

➡️ 이러한 단점을 보완하여 **함수형 컴포넌트**에서도 상태 관리와 생명주기 기능을 사용할 수 있도록 등장한 것이 **React Hook**입니다.

---
# React Component LifeCycle (컴포넌트 생명 주기)

React 컴포넌트는 다음과 같은 **생명 주기(Lifecycle)**를 거칩니다:

## 🔄 생명 주기 개요

- **탄생(Mount)** → **변화(Update)** → **제거(Unmount)** 의 과정을 순차적으로 거칩니다.
- 컴포넌트가 **생성되고**, **업데이트되며**, **제거되는 전체 흐름**을 생명 주기라고 하며,
- 각 단계마다 **특정 메서드 또는 훅(hook)**이 호출되어 필요한 작업을 수행할 수 있습니다.

---

## 📌 생명 주기의 세 가지 주요 단계

1. **Mount (마운트)**  
   컴포넌트가 **DOM에 처음 삽입될 때** 발생하는 단계입니다. 초기 렌더링 작업을 수행합니다.

2. **Update (업데이트)**  
   컴포넌트의 **props 또는 state가 변경되어 다시 렌더링**될 때 발생합니다.

3. **Unmount (언마운트)**  
   컴포넌트가 **DOM에서 제거될 때** 발생합니다. 정리(clean-up) 작업을 수행할 수 있습니다.

---

## 🧩 클래스형 컴포넌트에서의 생명주기 메서드

| 단계       | 메서드                      | 설명                                         |
|------------|-----------------------------|----------------------------------------------|
| Mount      | `constructor`               | 컴포넌트 생성자. 초기 state 설정 가능         |
|            | `componentDidMount`         | 컴포넌트가 마운트된 직후 실행됨              |
| Update     | `shouldComponentUpdate`     | 렌더링 여부를 결정                           |
|            | `componentDidUpdate`        | 업데이트 이후 실행됨                         |
| Unmount    | `componentWillUnmount`      | 컴포넌트 제거 직전에 호출, 정리 작업 수행    |

---

## ⚙️ 함수형 컴포넌트에서의 생명 주기: `useEffect` 훅

함수형 컴포넌트에서는 위의 생명주기 메서드 대신 `useEffect()` 훅을 사용하여 동일한 작업을 처리합니다.

---

# 🔧 React Hooks

## ✅ Hooks란?

**Hooks(훅)**은 특정 위치에 **원하는 함수가 실행되도록 갈고리를 거는 개념**에서 유래된 이름입니다.  
원래 존재하는 어떤 기능에 **갈고리(hook)를 걸어 끼어들어 실행**되도록 만드는 것을 의미합니다.

React에서 Hooks는 **state와 생명주기(lifecycle)** 같은 기능을 **함수형 컴포넌트에서 사용할 수 있게 해주는 기능**입니다.

---

## 🔄 Hooks의 등장 배경

- 과거에는 `state`와 `생명주기 메서드(lifecycle methods)`를 **클래스형 컴포넌트**에서만 사용할 수 있었습니다.
- 함수형 컴포넌트는 선언이 간단하고 가독성이 좋지만, 이러한 기능을 사용할 수 없다는 **제한이 있었습니다**.
- React v16.8에서 **Hooks가 도입되면서** 함수형 컴포넌트도 클래스형처럼 완전한 기능을 가지게 되었습니다.

---

## 📌 Hooks의 장점

- ✅ **클래스 없이도 React의 주요 기능 사용 가능**
- ✅ 코드가 **더 간결하고 가독성 향상**
- ✅ **로직의 재사용성** 증가 (Custom Hooks)
- ✅ **테스트 용이성** 향상
- ✅ 컴포넌트 간 상태 및 사이드 이펙트 관리가 용이

---

## 🧠 Hooks의 핵심 개념

React의 훅은 모두 **`use`로 시작하는 함수**입니다.

| Hook 이름        | 설명                                           |
|------------------|------------------------------------------------|
| `useState()`     | 컴포넌트에서 상태(state)를 선언하고 변경 가능     |
| `useEffect()`    | 생명주기 관리: 컴포넌트 mount/update/unmount 시 실행 |
| `useContext()`   | 전역 상태 관리 (Context API와 함께 사용)        |
| `useRef()`       | DOM 참조 또는 변경되지 않는 값 저장             |
| `useMemo()`      | 성능 최적화를 위한 메모이제이션                  |
| `useCallback()`  | 함수 메모이제이션으로 불필요한 렌더링 방지        |
| `useReducer()`   | 복잡한 상태 로직 관리 (Redux와 유사)             |

---

## 🛠 Custom Hook

- 개발자가 직접 정의한 훅은 **반드시 `use`로 시작하는 이름**을 사용해야 합니다.
- 예: `useFetch`, `useToggle`, `useForm` 등
- 이를 통해 재사용 가능한 로직을 분리하고, 여러 컴포넌트에서 공유할 수 있습니다.

---
# 🧩 useState()

## ✅ 개요

- `useState`는 **React Hook** 중 하나로, 함수형 컴포넌트에서 **상태(state)를 관리**할 수 있게 해주는 기능입니다.
- 기존의 클래스형 컴포넌트에서 사용하던 `this.state`와 `this.setState`를 **대체**합니다.
- 이 훅을 사용하면 함수형 컴포넌트에서도 상태를 정의하고 변경할 수 있으며, **상태값이 바뀔 때마다 컴포넌트가 자동으로 리렌더링**됩니다.

---

## 🛠 사용 방법

```jsx
const [state, setState] = useState(initialValue);
```

- state: 현재 상태 값
- setState: 상태를 변경하는 함수
- initialValue: 상태의 초기 값
---

# useState() 개념 요약표

| 항목               | 설명                                                         | 예시 코드                             |
|--------------------|--------------------------------------------------------------|-------------------------------------|
| 개념 설명          | React 함수형 컴포넌트에서 상태를 관리하는 Hook               | -                                   |
| 기본 사용법        | 상태 변수와 상태 변경 함수를 선언                            | `const [state, setState] = useState(초기값);` |
| 상태 변경          | 상태를 새로운 값으로 변경                                     | `setState(새로운값);`                |
| 객체 상태 관리     | 이전 상태를 복사하고 일부 값만 변경                           | `setState(prev => ({ ...prev, 변경값 }))` |
| 배열 상태 관리     | 기존 배열에 새 요소를 추가                                    | `setState([...배열, 새요소])`       |
| 비동기 특성        | 상태 변경 직후 값이 바로 반영되지 않을 수 있음               | -                                   |
| 함수형 업데이트    | 이전 상태 값을 기반으로 상태 변경 (안정적 상태 변경)          | `setState(prev => prev + 1)`        |
| 복잡한 상태 관리   | 상태가 복잡할 경우 useReducer 훅 사용 고려                   | -                                   |
---

# 🧩 React Hook: useEffect()

## ✅ 개념 설명

- `useEffect`는 React 함수형 컴포넌트에서 **부수 효과(side effect)**를 처리할 수 있게 해주는 Hook입니다.
- 부수 효과란 컴포넌트의 주요 기능 외에 추가적으로 실행되는 작업을 의미하며, 대표적으로 **데이터 fetching, 구독(subscription), DOM 직접 조작, 타이머 설정** 등이 있습니다.
- 클래스형 컴포넌트에서 사용하던 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 생명주기 메서드를 **대체**합니다.

---

## 🛠 사용법

```jsx
useEffect(setup, dependencies?);
```
- setup: 실행할 함수
- dependencies: 의존성 배열 → 특정 값이 변경될 때만 실행
---
# useEffect() 개념 및 코드 설명 표

| 실행 시점            | 코드 예시                                              | 설명                              |
|----------------------|-------------------------------------------------------|---------------------------------|
| 처음 한 번만 실행    | `useEffect(() => { ... }, [])`                         | 컴포넌트 마운트 시 실행, 언마운트 시 정리 함수 실행 |
| 특정 상태가 변경될 때 | `useEffect(() => { ... }, [state])`                    | `state` 값이 변경될 때마다 실행  |
| 매 렌더링마다 실행   | `useEffect(() => { ... })`                             | 의존성 배열이 없으면 매 렌더링 시 실행 |
| 언마운트 시 실행    | `useEffect(() => { return () => { ... }; }, [])`        | 컴포넌트가 제거될 때 정리 함수 실행 |
---

# useMemo()

## 개념 설명
- `useMemo`는 React Hook으로, 계산 결과를 재렌더링 간에 **캐싱**하여 불필요한 계산을 방지합니다.
- **memoization**이란, 특정 함수를 호출할 때 인수가 변경되지 않았다면 이전에 계산된 값을 재사용하는 기법입니다.
- 즉, `useMemo`는 컴포넌트가 다시 렌더링될 때마다 반복되는 고비용 계산을 피하고 성능을 최적화합니다.

## 동작 원리 및 사용법
- `useMemo`에 전달된 함수는 **렌더링이 일어나는 동안에만 실행**됩니다.
- 렌더링 중 실행해서는 안 되는 작업(예: 사이드 이펙트 함수)은 `useMemo`에 넣으면 안 됩니다. 이런 작업은 `useEffect`에 넣어야 합니다.
- 의존성 배열을 넣지 않으면 매 렌더링마다 함수가 실행되어 캐싱 효과가 없습니다.
  ```jsx
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b));

- 의존성 배열이 빈 배열 []이라면 컴포넌트가 마운트될 때만 함수가 호출됩니다.
```jsx
  ```const memoizedValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, []);
```
- 주로 마운트 시에만 계산해야 하는 값에 사용합니다.

## 사용해야 하는 경우
연산 비용이 큰 계산을 반복할 때

객체 또는 배열이 불필요하게 재생성될 때

의존성이 변경되지 않는 한 동일한 값을 유지해야 할 때

---

## 사용하지 않아도 되는 경우

간단한 연산이거나 최적화할 필요가 없을 때

값이 자주 바뀌는 경우 오히려 성능 저하가 발생할 수 있음

useEffect와 혼동하여 사이드 이펙트를 잘못 처리하는 경우

---
## 주의 사항

과도한 사용 주의: 모든 값을 memoization 하려고 하면 오히려 성능 저하를 초래할 수 있으므로 꼭 필요한 경우에만 사용하세요.

의존성 배열을 올바르게 지정해야 불필요한 계산을 방지할 수 있습니다.

값을 계산하는 함수는 반드시 순수 함수여야 하며, 외부 값을 변경하거나 외부 값에 의존해서는 안 됩니다.

---

# useCallback()

## 개념 설명
- `useCallback`은 React Hook으로, 함수 정의를 재렌더링 간에 **캐싱**하여 불필요한 함수 생성을 방지합니다.
- **메모이제이션**이란 특정 함수를 호출할 때 인수가 변경되지 않았다면 이전에 생성된 함수를 재사용하는 기법입니다.
- 즉, 컴포넌트가 리렌더링될 때 동일한 함수가 다시 생성되지 않도록 최적화하는 데 사용됩니다.
- `useCallback`은 컴포넌트가 다시 렌더링될 때마다 새로운 함수를 불필요하게 생성하는 것을 막아 성능을 향상시킵니다.

## 언제 사용해야 할까?

### 사용해야 하는 경우
- 자식 컴포넌트에 함수(props)를 전달할 때
- 이벤트 핸들러 함수가 불필요하게 재생성될 때
- 의존성이 자주 바뀌지 않는 경우

### 사용하지 않아도 되는 경우
- 단순한 함수는 사용하지 않아도 됨
- `useCallback`을 과도하게 사용하면 오히려 성능 저하를 일으킬 수 있음
- 함수를 자주 생성해도 성능에 큰 영향을 주지 않는 경우

## 사용 시 주의 사항
- **과도한 사용 주의**: 모든 함수를 `useCallback`으로 감싸는 것은 오히려 성능 저하를 초래할 수 있으므로 꼭 필요한 경우에만 사용하세요.
- **의존성 배열을 올바르게 지정**하여 불필요한 함수 생성을 방지해야 합니다.
- 함수는 **반드시 순수 함수**여야 하며, 외부 값을 변경하거나 외부 값에 의존해서는 안 됩니다.

## 장점
- 렌더링 성능 최적화: 불필요한 함수 생성을 방지하여 컴포넌트 렌더링 성능 향상
- 메모리 절약: 함수 재사용을 통해 메모리 사용량 감소

---

# useRef()

## 개념 설명
- `useRef`는 React Hook으로, 렌더링에 필요하지 않은 값을 참조할 수 있게 해줍니다.
- **Reference**란 특정 컴포넌트나 DOM 요소에 접근할 수 있는 객체를 의미합니다.
- `refObject.current`는 현재 참조하고 있는 DOM 요소나 값을 나타냅니다.
- `useRef`는 함수형 컴포넌트에서 DOM 요소에 직접 접근하거나, 값이 변경되어도 리렌더링을 유발하지 않는 변수를 저장할 때 사용됩니다.
- `useRef()` Hook은 변경 가능한 ref 객체를 반환하며, 이 객체의 `.current` 속성을 통해 DOM 요소에 접근하거나 컴포넌트가 다시 렌더링되어도 유지되는 값을 저장할 수 있습니다.

## 기본 문법
```jsx
const ref = useRef(initialValue);
```
initialValue: useRef가 초기화될 때 설정할 값입니다. 이 값은 current 프로퍼티에 저장됩니다.
